CompressedStrip_Project
Andrew Akerson
October 2017

This is a project that solves the inifite compressed strip project outlined
in "CompressedStrip.pdf" using a finite element formulation.

Included files:

  CompressedStrip_Project/source/bloch_eigs_first_bif.cc
  CompressedStrip_Project/source/CompressedStripPacaBloch.cc
  CompressedStrip_Project/source/Constituitive.cc
  CompressedStrip_Project/source/paca_continue.cc
  CompressedStrip_Project/source/paca_to_first_bif_instability.cc

  CompressedStrip_Project/include/CompressedStripPacaBloch.h
  CompressedStrip_Project/include/Constituitive.h

  CompressedStrip_Project/inputFiles/inputFileExample.in

  CompressedStrip_Project/CMakeLists.txt
  CompressedStrip_Project/README.txt

Building:
  The code was written for dealii-8.5.0, so that version (or higher) is recommended. Dealii
  should be installed with the UMFPACK and LAPACK flags on. This can be found at:
  https://www.dealii.org/developer/readme.html. Once dealii is set up with those extras,
  the code can be built much the same as the dealii "steps". In the "CompressedStrip_Project"
  directory,

    $ cmake -DDEAL_II_DIR=/path/to/installed/deal.II .

  Where /path/to/installed/deal.II is the location of your dealii installation. Then, the code
  can be compiled with:

    $ make all

  This should all work if dealii is installed with the extras described.

What it does:
  Overview:
    The code solves the finite element problem of a finite 2-D strip of material
    under displacement control with periodic boundary conditions. Symmetry and
    anti-symmetry constraints are applied in the vertical and horizontal directions,
    respectfully (this is to constrain the buckling to one mode). All of the present
    code uses a compressible neo-hookean energy. I am in the process of expanding this,
    hence the "Constiutive.*" files.

  Output works as follows:
    In the inputFile, the user specifies the output directory prefix, say "outputDirPrefix".
    Then, the name of the output directory is this prefix, appended with the number of primitive
    cells used, "#". All output for that run is then sent to:
    CompressedStrip_Project/outputDirPrefix_#/
    Usually, the following sub-directories will be present after a run (depending on what/if you are outputting):

      bloch_eigenvalues
      deformed_mesh
      displacement_from_uniform
      eigenvalues
      saved_state
      total_displacement
      load_info

    - deformed_mesh, displacement_from_uniform, and total_displacement contain the vtk files
      with data for what their name suggests. The output frequency is set from the input file.
      paca_to_first_bif_instability outputs with numbers starting at 0, and paca_continue
      outputs starting at 1000. This is because the visualization tool I am using (visit)
      wants all of the files plotted to be in the same directory and have the same prefix.

    - eigenvalues is a directory that holds text files when eigenvalues are outputted.
      Eigenvalues can be outputted with ElasticProblem<dim>:get_system_eigenvalues function
      where the given index is specified. This will output a file to this directory titled
      eigenvalues_index with the eigenvalues.

    - saved_state is a directory with the saved state that is outputted from
      paca_to_first_bif and is loaded in from paca_continue

    - bloch_eigenvalues are the eigenvalues that are outputted from bloch_eigs_first_bif

    - the loading information. This includes the lambda (loading) value, energy (per primitive cell),
      congugate loading (dE/dlambda per primitive cell), and displacement magnitude (per primite cell).
      The suffix at the end of the file generated by paca_to_first_bif is 0, and for paca_continue is 1.
      The suffix for bloch_eigs is 2.




Executables:

  paca_to_first_bif_instability:
    An input file of the format inputFileExample.in is taken in. It creates the mesh
    from the input file (with the mesh dimensions and the size of domain specified),
    and then uses a bisect method on the known priciple solution to find where the
    solution has an eigenvalue crossing (in the neighborhood of the loading parameter
    specified in the input file). The code then uses a pseudo-archlength continuation
    starting in the direction of the unstable eigenvector. Eigenvalues are found along
    the way. When an eigenvalue crossing is found, it outputs the current state
    (solution vectors and loading parameter) and the mesh.

  paca_continue
    An input file of the format inputFileExample.in is taken in. It then loads the
    state which should have been already outputted from paca_to_first_bif. Then, it
    pseudo-archlength iterates, starting in the direction of eigenvector corresponding
    to the smallest magnitude negative eigenvector. The symmetry constraints are enforced
    throughout this calculation.
    Note: I have added a function that loads an initial tangent. So one could change the
          code to use the loaded initial tangent instead of the eigenvector.

  bloch_eigs_first_bif
    An input file of the format inputFileExample.in is taken in. Along the first bifurcation
    (same one followed by paca_to_first_bif), the bloch wave eigenvalues are found
    and outputted in bloch_eigenvalues. Along the path, the symmetry constraints are present,
    but the bloch eigenvalues are found without using these symmetry constraints.




